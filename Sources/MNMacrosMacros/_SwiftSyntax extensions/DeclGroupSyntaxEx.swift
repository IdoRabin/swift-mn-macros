//
//  DeclGroupSyntaxEx.swift
//  SimplifiedEnumMacro
//
//  Created by ido on 29/09/2024.
//

import SwiftCompilerPlugin
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros

public extension DeclSyntax {
    
    func bestFoundName()->String? {
        // SyntaxParseable.logStringInterpolationParsingError()
        
        /*
         // Unnamed DeclSyntaxes: (have no .name property)
         accessorDecl
         extensionDecl
         operatorDecl
         
         // Named DeclSyntaxes: (have .name property)
         actorDecl
         ifConfigDecl
         classDecl
         associatedTypeDecl
         deinitializerDecl
         editorPlaceholderDecl
         editorPlaceholderDecl
         enumCaseDecl
         enumDecl
         functionDecl
         importDecl
         initializerDecl
         macroDecl
         macroExpansionDecl
         missingDecl
         poundSourceLocation
         precedenceGroupDecl
         protocolDecl
         structDecl
         subscriptDecl
         
         // TODO: Find how to exteact the "name" of the operator
         .extensionDecl
         .operatorDecl
         */
        
        // Named decl syntax provided the solution
        /*
         public protocol NamedDeclSyntax: SyntaxProtocol {
           /// ### Tokens
           ///
           /// For syntax trees generated by the parser, this is guaranteed to be `<identifier>`.
           var name: TokenSyntax {
             get
             set
           }
         }
         */
        if let aname = self.asProtocol(NamedDeclSyntax.self)?.name.trimmedDescription, aname.count > 0 {
            return aname
        }
        
        return nil
    }
}

public extension SyntaxProtocol {
    
    private func internal_RecourseChildren(where test: DeclGroupTest, stopOnFirst: Bool, viewMode: SyntaxTreeViewMode, depth: Int) throws -> [any SyntaxProtocol] {
        guard depth < DeclGroupSyntaxErrors.declGroupSyntaxMaxRecursion else {
            throw DeclGroupSyntaxErrors.DeclGroupSyntaxRecursionTooDeep
        }

        var result: [any SyntaxProtocol] = []
        if test(self, depth) {
            result.append(self)

            // Return if needed
            if stopOnFirst { return result }
        }

        for child in children(viewMode: viewMode) {
            if let child = child as? DeclGroupSyntax {
                try result.append(contentsOf:
                    child.internal_RecourseChildren(where: test, stopOnFirst: stopOnFirst, viewMode: viewMode, depth: depth + 1)
                )
            }

            // Return if needed
            if stopOnFirst, result.count > 0 { return result }
        }

        return result
    }

    func allRecoursedChildren(where test: DeclGroupTest, viewMode: SyntaxTreeViewMode = .all) throws -> [any SyntaxProtocol] {
        return try internal_RecourseChildren(where: test, stopOnFirst: false, viewMode: viewMode, depth: 0)
    }

    func firstRecoursedChild(where test: DeclGroupTest, viewMode: SyntaxTreeViewMode = .all) throws -> (any SyntaxProtocol)? {
        return try internal_RecourseChildren(where: test, stopOnFirst: true, viewMode: viewMode, depth: 0).first
    }
    
    
    typealias BestFoundNamedDecl = (item:DeclSyntax, name: String)
    
    /// Find the first child in the syntax that is of DeclSyntax AND has a name identifier
    /// - Parameter expectedName: expected name string, or nil if we are looking for the first decl with any name
    /// - Parameter excluding: excluding DeclSyntaxes that are excluded from the search:
    /// - Returns: the node syntax that is a DeclSyntax which has a name like the searched one
    func firstDeclChildWithName(_ expectedName:String? = nil, excluding: [SyntaxKind]) throws ->BestFoundNamedDecl? {
        
        var foundName : String = ""
        
        // Find declertion:
        guard let decl = try self.firstRecoursedChild(where: { item, depth in
            
            if excluding.contains(item.kind) {
                return false // excluded items are not tested
            }
            // decl.kind == .
            if let decl = item.as(DeclSyntax.self), let bfName = decl.bestFoundName() {
                foundName = bfName
                return true
            }
            return false
        })?.as(DeclSyntax.self) else {
            return nil
        }
        
        // Decl was found:
        foundName = foundName.components(separatedBy: .whitespacesAndNewlines).first!.trimmingCharacters(in: .whitespacesAndNewlines)
        return BestFoundNamedDecl(item:decl, name:foundName)
    }
}
